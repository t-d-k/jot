// DO NOT EDIT THIS FILE WITH AN EDITOR THAT REPLACES TABS WITH SPACES, OR YOU WILL GET AN ERROR ON RUN
/* jot2xml.cpp : converts jot files to xml

recursive descent parser.
as written, grammar is not LL(n), so there is a hack in the tokenizer to make
LL(1) this avoids having to use backtracking

to do:
change to use backtracking
allow [this] syntax for sub-node


see notes.jot#software projects
summary
in form
a
>b
>>>c

where > = tab
goes to <xml><LEV0>a<LEV1>b<LEV3>c</LEV3></LEV1><LEV0>

for now:
hardcoded schema


test cmdline
  "test convert.jot" -s -o  "test convert.test.xml" html (uses schema)

*/

/*
cope with
a|
  indented
  use dummy terminal "startBlockTag" . allows
a|b
  c
  as c under a
	************************************************************************************
ebnf:
with dummy terminals "incIndent" , "decIndent", "startLineTag", "startBlockTag"

terminals
  ident = all chars - {     ']', '[', '}', '{',  '|', '"', '.', '=',' ' } 
  textEl = all chars - {     ']', '[', '}', '{',  '|' ,' '}
  textNQEl= all chars - {     ']', '[', '}', '{',  '|', '"' ,' '}


grammar

  file = { block } .

  block =
  ( "incIndent" { blockLine } "decIndent" ) | tagBlock .

  text =  { textEl } .

  textNQ = { textNQEl } .

  blockLine = [ ( block |  line | tagLine ) ] "\n" .

  line = { lineEl } .

  lineEl = text | brackBlock | curlyBlock .

  quotedLineEl = ( """ textNQ """ ) | textNQEl .

  brackPhrase =  ( ident | '.' )  { tagParam } "|"  [ line ].

  brackBlock = "[" brackPhrase  "]" .

  curlyBlock = "{" line  "}" .

  tagParam = ident "=" quotedLineEl .

  tagLine = "startLineTag"  brackPhrase   .

  tagBlock = "startBlockTag"  brackPhrase [ block ] .

*/
#if defined(_MSC_VER)
#include "stdafx.h"
#endif
#include "tokenizer.h"

// reading a text file
#include <iostream>

#include <codecvt>
#include <fstream>
#include <string>

#include <cstring> // strcmp
#include <sstream> // for stringstream

#include <assert.h>

// containers
#include <list>
#include <map>
#include <vector>

#include <algorithm> // std::find

using namespace std;

typedef std::map<std::wstring, std::wstring> mapStrStr;
typedef std::list<wstring> strList;
typedef std::map<std::wstring, strList> mapStrList;

class parser {
protected:
  tokenizer &toker;
  wofstream xmlFile;

  bool checkSchema, buildingSchema;
  bool isDefault, isComment;

  // used in building schema
  wstring parentIdent;

  mapStrStr *schemaDefs;  // maps tags to default child
  mapStrList *schemaOpts; // maps tags to list of optional children

  token curTok() { return toker.curTok; }
  // output fns
  void outTabs(int count);
  void outStartTag(wstring tag, int indent);
  void outStartTag(wstring tag);           // overload
  void outEndTag(wstring tag, int indent); // overload
  void outEndTag(wstring tag);             // overload

  bool eof() { return toker.eof(); }
  wstring getTagForLevel(int indent, const wstring parentTag);
  void checkTagValid(const wstring ntag, const wstring parentTag);

  void expect(const tokType exp);
  void nextToken();
  void parseIdent();

  /********* parse functions - see ebnf *********/
  void parseIndentBlock(const wstring parentTag, bool outputTags);
  void parseLineEl(const wstring parentTagt);
  void parseBlockLine(const wstring thisTag);

  void parseTagLine(const wstring parentTag);
  void parseTagBlock(const wstring parentTag);
  // parse text that is not a whole line
  void parseText();
  void parseTextNQ();
  void parseTextNQEl();
  /*
  tagParam = ident "=" quotedLineEl .
  */
  void parseTagParam(const wstring parentTag);
  /*
    brackPhrase =  ( ident | '.' )  { tagParam } "|"  [ line ].
  */
  wstring parseBrackPhrase(const wstring parentTag, bool isPara /* is paragraph on own (wrap in p)*/);

  /*  brackBlock = "[" brackPhrase "]" .  */
  void parseBrackBlock(const wstring parentTag);

  /*  curlyBlock = "{" line  "}" . */
  void parseCurlyBlock(const wstring parentTag);

  /*
  quotedLineEl = ( """ textNQ """ ) | textNQEl .
  */
  void parseQuotedLineEl();

  /*
  line = { lineEl } .
  */
  void parseLine(const wstring parentTag);

public:
  parser(tokenizer &atok, const string xmlPath, mapStrStr *const schemaDefs,
         /* maps tags to default child*/ mapStrList *const schemaOpts);
  ~parser();

  void parseFile(bool acheckSchema, bool abuildingSchema);
  void addToSchema(const wstring parent, const wstring child, bool isDefault);

}; // class parser

// do not edit this file with an editor that replaces tabs with spaces, or you will get an error on run
// matches default.schema.jot
const wstring DEFAULT_SCHEMA = LR"(
xml
	default|LEV
	title
	comment|common to all tags
	id
	when
	class
	comment
	case
img
	default|src
	title
	comment|common to all tags
	id
	when
	class
	comment
	border
	alt
	width
	height
	case
video
	default|src
	title
	comment|common to all tags
	id
	when
	class
	comment
	border
	alt
	width
	height
	case
LEV
	default|LEV
	comment| indent level shows heading type
	comment|common to node type tags (LEV, list, case, table)
	quote
	list
	ol
	ul
	a
	L
	todo
	pre
	p
	img
	video
	em
	strong
	code
	form
	b
	table
	citation
	comment|common to all tags
	id
	when
	class
	comment
	case
id
	quote
	default|p
	comment|common to all tags
	when
	class
	comment
	case
p
	default|LEV
	a
	L
	code
	list
	b
	comment|common to all tags
	id
	when
	class
	comment
	case
	todo
	ul
	id
a
	default|r
	comment|common to all tags
	id
	when
	class
	comment
	target
	dld
	rel
	case
	img
L
	comment|no subnodes allowed
code
	default|p
	comment|common to all tags
	id
	when
	class
	comment
comment
	default|LEV
	todo
	img
	a
	L
	comment|common to all tags
	id
	when
	class
	code
	em
citation
	default|a
	L
	comment|common to all tags
	id
	when
	class
	comment
quote
	default|p
	comment|common to all tags
	id
	when
	class
	comment
ol
	default|p
	comment|common to all tags
	id
	when
	class
	comment
	ul
	em
ul
	default|p
	img
	code
	comment|common to all tags
	id
	when
	class
	comment
	em
	a
	ul
	ol
comment| no difference bt case and LEV, but xsl checks case must have 'when' subnode
case
	default|LEV
	comment| indent level shows heading type
	comment|common to node type tags (LEV, list, case, table)
	quote
	list
	ol
	ul
	a
	L
	todo
	pre
	p
	img
	em
	strong
	code
	form
	b
	table
	comment|common to all tags
	id
	when
	class
	comment
	case
when
	comment|as attribute of parent - no subnodes allowed
list
	comment|  sim to when
	default|LEV
	num
	comment|common to node type tags (LEV, list,table)
	quote
	list
	ol
	ul
	a
	L
	todo
	pre
	p
	img
	em
	strong
	code
	form
	b
	table
	comment|common to all tags
	id
	when
	class
	comment
	case
num
	comment| no subnodes - ident only = "ol", "ul", "numbered" or empty (= ul)
table
	default|row
	header
	caption
	comment|common to node type tags (LEV, list, case, table)
	quote
	list
	ol
	ul
	a
	L
	todo
	pre
	p
	img
	em
	strong
	code
	form
	b
	table
	comment|common to all tags
	id
	when
	class
	comment
	case
row
	default|cell
	comment|common to all tags
	id
	when
	class
	comment
	case
header
	default|cell
	comment|common to all tags
	id
	when
	class
	comment
	case
cell
	default|LEV
	comment|common to all tags
	id
	when
	class
	comment
	case
id
	comment|common to all tags
	when
	class
	comment
pre
	default|p
	comment|common to all tags
	id
	when
	class
	comment
	case
form
	default|action
	method
	target
	input
	img
input
	default|value
	type
	name
	src
	border
	alt
comment|style-only tags	
em
	code
	comment
		





)";

void parser::addToSchema(const wstring parent, const wstring child, bool isDefault) {
  strList *childList;
  auto it = schemaOpts->find(parent);
  // check is valid tag - no special chars in parent or child
  // dont whitelist - allow unicode
  // const wstring VALID_TAG_CHARS = L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";

  // reserve all special chars to allow for language expansion (but '_' and '-' allowed)
  const wstring INVALID_TAG_CHARS = L"\t ¬`|\\<>?,./:@~;'#{}[]!\"£$%^&*()+=";

  if (parent.find_first_of(INVALID_TAG_CHARS) != std::string::npos)
    throw SyntaxError(L"Tag contains invalid chars - '" + parent + L"'");
  if (child.find_first_of(INVALID_TAG_CHARS) != std::string::npos)
    throw SyntaxError(L"Tag contains invalid chars - '" + child + L"'");

  if (it == schemaOpts->end()) {
    // not a mem leak - freed on close
    childList = new strList();
  } else {
    childList = &it->second;
  }

  (*childList).push_back(child);
  schemaOpts->insert(std::make_pair(parent, *childList));

  if (isDefault) {
    schemaDefs->insert(std::make_pair(parent, child));
  }
}
/***************
parser
**************/

/*
brackPhrase =  ( ident | '.' )  { tagParam } "|"  [ line ].
returns closing tag
*/
wstring parser::parseBrackPhrase(const wstring parentTag, bool isPara) {
  //  output tag as node
  wstring tag;
  if (curTok().type == eDot) {
    // dot means default tag
    tag = getTagForLevel(curTok().indent, parentTag);
    nextToken();
  } else {
    tag = curTok().str;
    isDefault = (buildingSchema && (tag == L"default"));
    isComment = (buildingSchema && (tag == L"comment"));
    checkTagValid(tag, parentTag);
    expect(eIdent);
  }
  outStartTag(tag);

  if (!buildingSchema && isPara)
    outStartTag(L"p", curTok().indent);

  try {
    while (curTok().type != ePipe) {
      parseTagParam(tag);
    }
    expect(ePipe);
    tokType type = curTok().type;

    if ((type != eIncIndent) && (type != eDecIndent) && (type != eTagLine) && (type != eRightBrace) &&
        (type != eRightCurly) && (type != ePipe) && (type != eNewLine) && (type != eTagBlock)) {
      parseLine(tag);
    }
  } catch (EofExcept) {
  }
  if (!buildingSchema && isPara)
    outEndTag(L"p");
  return tag;
}

/*brackBlock = "[" brackPhrase "]" .*/
void parser::parseBrackBlock(const wstring parentTag) {
  expect(eLeftBrace);
  wstring tag = parseBrackPhrase(parentTag, false);
  wstring after = curTok().after;
  expect(eRightBrace);

  outEndTag(tag);
  if (!buildingSchema)
    xmlFile << after;
}

/*  curlyBlock = "{" line  "}" . */
void parser::parseCurlyBlock(const wstring parentTag) {
  expect(eLeftCurly);
  wstring tag = getTagForLevel(curTok().indent, parentTag);

  outStartTag(tag);
  if (!buildingSchema)
    xmlFile << curTok().after;

  try {

    tokType type = curTok().type;

    if ((type != eIncIndent) && (type != eDecIndent) && (type != eTagLine) && (type != eRightBrace) &&
        (type != eRightCurly) && (type != ePipe) && (type != eNewLine) && (type != eTagBlock)) {
      parseLine(tag);
    }
  } catch (EofExcept) {
  }

  expect(eRightCurly);

  outEndTag(tag);
  if (!buildingSchema)
    xmlFile << curTok().after;
}

/*
quotedLineEl = ( """ textNQ """ ) | textNQEl .
*/
void parser::parseQuotedLineEl() {
  // parse fns output string
  if (curTok().type == eQuote) {
    nextToken();
    parseTextNQ();
    expect(eQuote);
  } else {
    parseTextNQEl();
  }

} // parseQuotedLineEl

/*
line = { lineEl } .
*/
void parser::parseLine(const wstring parentTag) {

  while ((curTok().type == eLeftBrace) || (curTok().type == eIdent) || (curTok().type == eQuote) ||
         (curTok().type == eEquals) || (curTok().type == eDot) || (curTok().type == eLeftCurly)) {
    parseLineEl(parentTag);
  }
} // parseLine

void parser::outTabs(int count) {
  while (count-- > 0)
    xmlFile << '\t';
}

void parser::nextToken() { toker.getNextToken(); }

void parser::expect(const tokType exp) {

  if (curTok().type != exp) {
    wstring err = L"expected token '";
    err += toker.tokType2str(exp);
    err += L"' got '";
    err += toker.tokType2str(curTok().type) + L"'";
    throw SyntaxError(err);
  }
  nextToken();
} // expect

// textNQ = { textNQEl } .
void parser::parseTextNQ() {
  while ((curTok().type == eIdent) || (curTok().type == eEquals) ||
         (curTok().type == eDot)) {
    if (!buildingSchema)
      xmlFile << unescapeText(curTok().str) << curTok().after;
    
    nextToken();
  }
  
} // parseTextNQ

void parser::parseTextNQEl() {
  if ((curTok().type == eIdent) || (curTok().type == eEquals) ||
         (curTok().type == eDot)) {
  }else{
    throw SyntaxError(L"Text element: unexpected token - " + toker.tokType2str(curTok().type) );
  }
  while ((curTok().type == eIdent) || (curTok().type == eEquals) ||
         (curTok().type == eDot)) {
    if (!buildingSchema)
      xmlFile << unescapeText(curTok().str) << curTok().after;
    if (curTok().after.length() >0) {
       nextToken();
      break;
    }
    nextToken();
   
  }
  
  
} // parseTextNQEl

void parser::parseTagParam(const wstring parentTag) {
  //  output tag as node
  wstring tag = curTok().str;
  checkTagValid(tag, parentTag);
  outStartTag(tag);
  try {
    expect(eIdent);
    expect(eEquals);
    parseQuotedLineEl();
  } catch (EofExcept) {
  }
  outEndTag(tag);
} // parseTagParam

// text =  { textEl } .
/// <summary>
/// parses text not containing newlines
/// </summary>
/// <param name="text">string to parse</param>
void parser::parseText() {

  while ((curTok().type == eIdent) || (curTok().type == eQuote) || (curTok().type == eEquals) ||
         (curTok().type == eDot)) {
    if (!buildingSchema)
      xmlFile << unescapeText(curTok().str) << curTok().after;

    nextToken();
  }

} // parseText

/*
blockLine = [ ( block |  line | tagLine ) ] "\n" .
*/
void parser::parseBlockLine(const wstring thisTag) {
  auto typ = curTok().type;
  //   int sIndent = curTok().indent;
  //  wstring stag ;
  if (buildingSchema && (typ == eIdent) && (curTok().indent == 0))
    parentIdent = curTok().str;
  isDefault = false;
  isComment = false;
  switch (typ) {
  case eTagBlock:
    parseTagBlock(thisTag);
    break;
  case eIncIndent: // increase indent
    parseIndentBlock(thisTag, true);
    break;
  case eTagLine: // eg "a b=c|"
                 // if (!buildingSchema)           outStartTag(L"p", curTok().indent);
    parseTagLine(thisTag);
    //       if ( !buildingSchema)        outEndTag(L"p");
    break;
  case eIdent:
  case eLeftBrace:
  case eLeftCurly:
  case eEquals:
  case eQuote:
  case eDot:

    // stag = getTagForLevel(sIndent + 1, thisTag);
    if (!buildingSchema)
      outStartTag(L"p", curTok().indent);
    try {
      parseLine(thisTag);
    } catch (EofExcept) {
    }
    //
    if (!buildingSchema)
      outEndTag(L"p");
    break;
  case eNewLine:
    break;
  default:
    throw SyntaxError(L"parseBlockLine: unexpected token - " + toker.tokType2str(curTok().type) + L" parent - " +
                      thisTag);
  }
  // nextToken();
  // newline is implied in incindent

  if (!((curTok().type == eNewLine) || (curTok().type == eIncIndent) || (curTok().type == eDecIndent))) {
    throw SyntaxError(L"unexpected token in Block Line - " + toker.tokType2str(curTok().type) + L", parent: " +
                      thisTag);
  }
  if (curTok().type == eNewLine) {
    nextToken();
  }

} // parseBlockLine

wstring parser::getTagForLevel(int indent, const wstring parentTag) {

  mapStrStr::iterator it = schemaDefs->begin();
  it = schemaDefs->find(parentTag);

  if (it == schemaDefs->end()) {
    if (checkSchema) {
      throw SyntaxError(L"tag does not have a default child in schema: " + parentTag);
    } else {
      // hardcoded schema here
      /*
       * xml
       *  default|LEV
       * LEV
       *  default|LEV
       */
      // this is only used when processing schema or if checkSchema is false
      // todo: when builidng schema: build this default schema first, then can
      // have checkSchema true
      if (indent == 0) {
        return L"xml";
      } else {
        return L"LEV";
      }
    }
  } else {
    return schemaDefs->find(parentTag)->second;
  }
}

void parser::checkTagValid(const wstring ntag, const wstring parentTag) {
  if (checkSchema) {
    auto it = schemaOpts->begin();
    it = schemaOpts->find(parentTag);
    if (it == schemaOpts->end()) {
      throw SyntaxError(L"tag does not have any optional children in schema: " + parentTag);
    } else {
      std::list<wstring> list = it->second;

      auto lit = std::find(list.begin(), list.end(), ntag);
      if (lit == list.end()) {
        throw SyntaxError(L"schema does not allow tag \"" + parentTag + L"\" to have child \"" + ntag + L"\"");
      }
    }
  }
}

/// <summary>
/// output "\t<tag>\n"
/// </summary>
/// <param name="indent">number of tabs to indent by</param>
void parser::outStartTag(wstring tag, int indent) {
  if (!buildingSchema) {
    xmlFile << endl;
    outTabs(indent);
    outStartTag(tag);
  }
}

/// <summary>
/// output "<tag>"
/// </summary>
void parser::outStartTag(wstring tag) { xmlFile << "<" << tag << ">"; }

/// <summary>
/// output ">></tag>\n"
/// </summary>
/// <param name="indent">number of tabs to indent by</param>
void parser::outEndTag(wstring tag, int indent) {
  outTabs(indent);
  outEndTag(tag);
  xmlFile << endl;
}

/// <summary>
/// output "</tag>"
/// </summary>
void parser::outEndTag(wstring tag) { xmlFile << "</" << tag << ">"; }

/// <summary>
/// parse line of form "\na b=c d=e|\n"
/// </summary>
/* tagLine = "startLineTag"  brackPhrase . */
void parser::parseTagLine(const wstring parentTag) {
  expect(eTagLine); // should be guaranteed by trick in tokenizer

  wstring tag = parseBrackPhrase(parentTag, true);
  outEndTag(tag);
}

/* tagBlock = "startBlockTag"  brackPhrase [ block ] . */
void parser::parseTagBlock(const wstring parentTag) {
  expect(eTagBlock); // should be guarenteed by trick in tokenizer
  xmlFile << endl;
  int indent = curTok().indent;
  outTabs(indent);
  wstring tag = parseBrackPhrase(parentTag, false);

  if (curTok().type == eIncIndent) {
    parseIndentBlock(tag, false);
  }
  outEndTag(tag, indent);
}

void parser::parseIdent() {

  if (curTok().type != eIdent)
    throw SyntaxError(L"ident expected, got - " + toker.tokType2str(curTok().type));
  // added to schema elsewhere
  if (!buildingSchema) {
    xmlFile << unescapeText(curTok().str) << curTok().after;
  }
  nextToken();
}

// ( "incIndent" { blockLine } "decIndent" )
// iff outputTags then output default tags
void parser::parseIndentBlock(const wstring parentTag, bool outputTags) {

  expect(eIncIndent);
  int sIndent = curTok().indent - 1;

  wstring stag = getTagForLevel(sIndent + 1, parentTag);
  if (outputTags) {
    if (!buildingSchema)
      outStartTag(stag, sIndent);
  } else {
    stag = parentTag;
  }
  try {
    while (curTok().type != eDecIndent) {
      parseBlockLine(stag);
    }
  } catch (EofExcept) {
  }
  xmlFile << endl;
  if (outputTags && !buildingSchema)
    outEndTag(stag, sIndent);

  expect(eDecIndent);
}

/*
  lineEl = text | brackBlock | curlyBlock .
*/
void parser::parseLineEl(const wstring parentTag) {
  tokType type = curTok().type;
  // add nodes to schema - only add 2nd level nodes to top level as parent
  if (buildingSchema && (type == eIdent) && (curTok().indent > 0) && !isComment)
    addToSchema(parentIdent, unescapeText(curTok().str), isDefault);

  switch (type) {
  case eLeftBrace:
    parseBrackBlock(parentTag);
    break;
  case eLeftCurly:
    parseCurlyBlock(parentTag);
    break;
  case eIdent:
  case eQuote:
  case eEquals:
  case eDot:
    parseText();
    break;
  default:
    throw SyntaxError(L"unexpected token - '" + toker.tokType2str(type) + L"' in Line Element. Parent - " + parentTag);
  }
  // nextTok();

} // parseLineEl

/*
file = { block } .
*/
void parser::parseFile(bool acheckSchema, bool abuildingSchema) {

  checkSchema = acheckSchema;
  buildingSchema = abuildingSchema;

  toker.rewind();

  wstring parentTag = L"";
  if (!buildingSchema)
    xmlFile << endl;
  try {
    nextToken();
    // ideally would be one top level entry, but if multiple ones, treat as
    // <xml> childs
    while (!eof()) {
      if (curTok().type == eIncIndent) {
        parseIndentBlock(parentTag, true);
      } else {
        parseTagBlock(parentTag);
      }
    }
  } catch (EofExcept) {
  }
  //	outEndTag( parentTag  );
  if (!buildingSchema)
    xmlFile << endl;
  assert(toker.eof());
}

parser::~parser() {}

parser::parser(tokenizer &atok, const string xmlPath, mapStrStr *const schemaDefs,
               /* maps tags to default child*/ mapStrList *const schemaOpts)
    : toker(atok), xmlFile(xmlPath), schemaDefs(schemaDefs), schemaOpts(schemaOpts) {

  // jotFile	= new wifstream (jotPath);
  // xmlFile	= new wofstream(xmlPath);
  // read/write as UTF-8
  // std::locale mylocale("English_United States.utf");
  // TODO: OS specific
  xmlFile.imbue(locale(xmlFile.getloc(), new codecvt_utf8_utf16<wchar_t>));

  checkSchema = false;
  // schemaDefs = nullptr;
  // test_file_ucs2();
}

void parseFileFromPath(const string jotPath, wistream &jotStream, const string xmlPath, mapStrStr &defaults,
                       mapStrList &opts, bool checkSchema, bool buildSchema) {

  tokenizer tokS(jotStream);

  parser *p = new parser(tokS, xmlPath, &defaults, &opts);
  try {
    p->parseFile(checkSchema, buildSchema);

    // "" = lev0, xml is only valid subnode - not in schema files
    if (buildSchema)
      p->addToSchema(L"", L"xml", true);
  } catch (SyntaxError &e) {
    /* follow gcc format eg:
      FtlAtlasII/MetaRecord.h:70:3: error: redefinition of typedef 'PageStripeDef'
      FtlAtlasII/BlockStripeContainer.h:36:31: note: previous declaration of
      'PageStripeDef' was here
    */
    cerr << jotPath << ":" << tokS.lineNum << ":" << tokS.linePos << ": Syntax error: " << e.what() << '\n';
    free(p);
    exit(5);
  }
}

int main(int argc, char *argv[]) {

  // process params
  string jotPath = "", xmlPath = "", schemaPath = "";
  bool checkSchema = true;
  bool buildSchema = false;

  const string USAGE = "Usage is jot2xml <jotfile> [ -o <xmlfile> ] [ -s <schema file>] [ -k ]\n";
  if (argc < 2) {
    std::cout << USAGE;
    return 2;
  } else {

    int i = 1;
    while (i < argc) {
      if (!strcmp(argv[i], "-o")) {
        if (++i >= argc) {
          cout << USAGE;
          return 3;
        }
        xmlPath = argv[i++];
      } else {
        if (!strcmp(argv[i], "-k")) {
          checkSchema = false;
          i++;
        } else {

          if (!strcmp(argv[i], "-s")) {
            buildSchema = true;
            if (++i >= argc) {
              cout << USAGE;
              return 5;
            }
            schemaPath = argv[i++];
          } else {
            jotPath = argv[i++];
          }
        }
      }
    }
  }

  if (jotPath == "") {
    cerr << USAGE << '\n';
    return 4;
  }

  if (xmlPath == "") {
    xmlPath = jotPath + ".xml";
  }

  mapStrStr defaults;
  mapStrList opts;

  if (buildSchema) {
    wifstream schemaStream(schemaPath);
    if (!schemaStream.is_open()) {
      cerr << "Unable to open file: " << schemaPath << '\n';
      exit(1);
    }
    parseFileFromPath(schemaPath, schemaStream, "", defaults, opts, false, true);
    schemaStream.close();

  } else {
    std::wistringstream defSchema(DEFAULT_SCHEMA);
    parseFileFromPath("DEFAULT SCHEMA", defSchema, "", defaults, opts, false, true);

    // TODO: use default file or hardcode text  buildHtmlSchema(*p,opts,
    // defaults);
  }
  wifstream jotStream(jotPath);
  if (!jotStream.is_open()) {
    cerr << "Unable to open file: " << jotPath << '\n';
    exit(1);
  }
  parseFileFromPath(jotPath, jotStream, xmlPath, defaults, opts, checkSchema, false);
  jotStream.close();

  return 0;
}
